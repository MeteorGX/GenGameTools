# 心跳包推送

因为游戏服务端大部分都是采用长连接的方式, 而其中可能因为放置过久导致连接长时间没有消息包推送而主动中断.

> 在 linux 服务器当中也有设定 `Socket` 超时设定(`tcp_keepalive_time|tcp_keepalive_intvl`)

虽然系统底层提供了 `keepalive` 设定, 但是对于游戏服务端来说最好采用自己方式处理可以方便自己做时长维护.

而在心跳包推送的流程之中基本上分为以下类型:

- `主动型心跳`: 由客户端发起类似 `echo` 方式不断 `ping|pong` 请求响应数据
- `被动型心跳`: 由服务端不断定时推送, 客户端则是不断接收协议数据即可.

> 有的挂机游戏可能挂机几分钟才会由服务端推送最终结果, 在此期间都是客户端自己做运算和动画, 而长度 Socket 闲置会被直接服务端主动中断

这里需要和客户端沟通好, 如果需要主动推送需要客户端在授权完成之后 `设置定时器不断用Socket推送网络消息包`,
这里部分就是客户端需要处理的工作比较多; 而被动性心跳则无需客户端处理, 在授权之后会由服务端生成定时器定时推送.

两者的区别就是定时器的启动所有者是由哪里构建, 采用 `主动心跳`
好处就是定时器移到客户端方便把定时器负载成本转移客户设备;  
而 `被动心跳` 会消耗服务器的CPU资源来调度定时器但是好处就是可以附带上特殊信息给客户端校正.

这里的实现方法基本没什么需要重点处理的, 返回协议基本上总结一下就是以下方式.

- 主动推送协议

```plain
.c2s_sys_heartbeat_req
    //请求心跳包
    {
        uint:timestamp  //客户端时间戳, 只是服务端打印确认客户端时间误差
    }

.s2c_sys_heartbeat_res
    //响应心跳包
    {
        //距离上次心跳的偏移量, 毫秒级别
        //通过比较当前帧与上一帧的时间差来得到时间增量, 再将这个时间差转换为秒(通过除以1000)得出
        float:deltatime 
    }
``` 

当然如果没有实际作用的情况, `deltatime` 直接返回给客户端秒级的时间戳亦可, 还省下一次计算方法.

> 心跳作用不大的情况, 直接返回秒级时间戳就行了, 基本上只用来维持 `Socket` 活跃度就行了

- 被动推送协议

```plain
.s2c_sys_heartbeat_res
    //响应心跳包
    {
        uint:timestamp  //服务端时间戳
    }
```

这个简单返回就行了, 不需要做太多处理.


